#' Evaluate Strategy
#' 
#' Given an unevaluated strategy, an initial number of 
#' individual and a number of cycle to compute, returns the 
#' evaluated version of the objects and the count of 
#' individual per state per model cycle.
#' 
#' `init` need not be integer. E.g. `c(A = 1, B = 0.5, C =
#' 0.1, ...)`.
#' 
#' @param strategy An `uneval_strategy` object.
#' @param parameters Optional. An object generated by 
#'   [define_parameters()].
#' @param cycles positive integer. Number of Markov Cycles 
#'   to compute.
#' @param init numeric vector, same length as number of 
#'   model states. Number of individuals in each model state
#'   at the beginning.
#' @param method Counting method.
#' @param expand_limit A named vector of state expansion 
#'   limits.
#' @param inflow Numeric vector, similar to `init`. Number
#'   of new individuals in each state per cycle.
#' @param strategy_name Name of the strategy.
#'   
#' @return An `eval_strategy` object (actually a list of 
#'   evaluated parameters, matrix, states and cycles 
#'   counts).
#'   
#' @example inst/examples/example_eval_strategy.R
#'   
#' @keywords internal
eval_strategy <- function(strategy, parameters, cycles, 
                          init, method, expand_limit,
                          inflow, strategy_name) {
  
  stopifnot(
    cycles > 0,
    length(cycles) == 1
  )
  
  # Extract and count states
  states <- get_states(strategy)
  n_states = length(states)
  
  # Extract transitions
  transitions <- get_transition(strategy)
  
  # Interpolate to determine propogation of state_time
  i_params <- interpolate(parameters)
  i_state <- interpolate(states, more = as_expr_list(i_params))
  i_trans <- interpolate(transitions, more = as_expr_list(i_params))
  
  # Determine which states need to be expanded
  state_td <- has_state_time(i_state)
  mat_td <- has_state_time(i_trans) %>%
    matrix(nrow = n_states, ncol = n_states, byrow = TRUE) %>%
    apply(1, any)
  to_expand <- state_td | mat_td
  
  # Build table to determine number of tunnels for each state
  expand_table <- tibble::tibble(
      .state = attr(states, "names"),
      .expand = to_expand,
      .limit = ifelse(to_expand, expand_limit, 1)
    )%>%
    plyr::ddply(
      ".state",
      function(st) {
        if(st$.expand) full_names <- paste0(".", st$.state, "_", seq_len(st$.limit))
        else full_names <- st$.state
        tibble::tibble(
          state_time = seq_len(st$.limit),
          .limit = st$.limit,
          .full_state = full_names,
          .expand = st$.expand
        )
      }
    )
  
  # Inform user about state expansion
  if(any(expand_table$.expand)){
    expanded <- expand_table %>%
      dplyr::filter(.expand) %>%
      dplyr::distinct(.state)
    message(
      sprintf(
        "%s: detected use of 'state_time', expanding state%s: %s.",
        strategy_name,
        plur(length(expanded$.state)),
        paste(expanded$.state, collapse = ", ")
      )
    )
  }
  
  # Evaluate parameters
  e_parameters <- eval_parameters(
    parameters,
    cycles = cycles,
    strategy_name = strategy_name,
    max_state_time = max(expand_table$.limit)
  )
  
  # Evaluate Initial State Values
  e_start_values <- eval_starting_values(
    strategy$starting_values,
    e_parameters
  )
  
  # Evaluate Initial Counts
  e_init <- eval_init(
    init,
    e_parameters,
    expand_table
  )
  
  # Inflow (now includes init)
  e_inflow <- eval_inflow(
    inflow,
    e_parameters,
    expand_table
  )
  
  # Evaluate States
  e_states <- eval_state_list(
    get_states(strategy),
    e_parameters,
    expand_table
  )
  
  # Evaluate Transitions
  e_transition <- eval_transition(
    get_transition(strategy),
    e_parameters,
    expand_table
  )
  
  # Compute counts
  count_table <- compute_counts(
    x = e_transition,
    init = e_init,
    inflow = e_inflow
  ) %>%
    correct_counts(method = method)
  
  # Compute values
  values <- compute_values(
    states = e_states,
    counts = count_table,
    init = e_init,
    inflow = e_inflow,
    starting = e_start_values
  )
  
  # Get counts of individuals
  n_indiv <- sum(e_inflow) + sum(e_init)
  
  # Aggregate over states
  count_table_agg <- plyr::dlply(
    expand_table,
    ".state",
    function(st) rowSums(count_table[st$.full_state])
  ) %>%
    do.call(tibble::tibble, .)
  
  structure(
    list(
      parameters = e_parameters,
      transition = e_transition,
      states = e_states,
      counts = count_table_agg,
      values = values,
      e_init = e_init,
      e_inflow = e_inflow,
      n_indiv = n_indiv,
      cycles = cycles,
      expand_limit = expand_limit
    ),
    class = c("eval_strategy")
  )
}

get_eval_init <- function(x) {
  UseMethod("get_eval_init")
}

get_eval_init.eval_strategy <- function(x) {
  x$e_init
}

get_eval_inflow <- function(x) {
  UseMethod("get_eval_inflow")
}

get_eval_inflow.eval_strategy <- function(x) {
  x$e_inflow
}

get_n_indiv <- function(x) {
  UseMethod("get_n_indiv")
}

get_n_indiv.eval_strategy <- function(x) {
  x$n_indiv
}

#' Compute Count of Individual in Each State per Cycle
#' 
#' Given an initial number of individual and an evaluated 
#' transition matrix, returns the number of individual per 
#' state per cycle.
#' 
#' Use the `method` argument to specify if transitions 
#' are supposed to happen at the beginning or the end of 
#' each cycle. Alternatively linear interpolation between 
#' cycles can be performed.
#' 
#' @param x An `eval_matrix` or
#'   `eval_part_surv` object.
#' @param init numeric vector, same length as number of 
#'   model states. Number of individuals in each model state
#'   at the beginning.
#' @param inflow numeric vector, similar to `init`.
#'   Number of new individuals in each state per cycle.
#'   
#' @return A `cycle_counts` object.
#'   
#' @keywords internal
compute_counts <- function(x, ...) {
  UseMethod("compute_counts")
}

#' @export
compute_counts.eval_matrix <- function(x, init, inflow, ...) {
  
  n_state <- get_matrix_order(x)
  n_cycle <- length(x)
  state_names <- get_state_names(x)
  
  if (! ncol(inflow) == get_matrix_order(x)) {
    stop(sprintf(
      "Number of columns of 'inflow' matrix (%i) differs from the number of states (%i).",
      ncol(inflow),
      get_matrix_order(x)
    ))
  }
  
  # Make a diagonal matrix of inital state vector
  init_mat = diag(init)
  
  # Do element-wise multiplication to get the numbers
  # undergoing each transition
  i <- 0
  calc_trans <- function(x, y) {
    i <<- i + 1
    (colSums(x) + diag(unlist(inflow[i, ]))) * y
  }
  uncond_trans <- Reduce(
    calc_trans,
    x,
    init_mat,
    accumulate = TRUE
  ) %>%
    unlist %>%
    array(c(n_state,n_state,n_cycle+1))
  
  # Sum over columns to get trace
  counts_array <- colSums(uncond_trans, dim=1) %>% t
  
  # Create an indicator array for transitions representing inter-state
  # transitions and multiply by unconditional transition probs
  zero_diag <- diag(1, n_state)
  zero_diag[ ,!attr(x,"entry")] <- 1
  zero_diag <- zero_diag %>%
    rep(n_cycle + 1) %>%
    array(c(n_state, n_state, n_cycle + 1))
  trans_counts <- uncond_trans * (1 - zero_diag)
  
  # Convert counts to data_frames
  counts_df <- dplyr::as.tbl(as.data.frame(counts_array))
  colnames(counts_df) <- state_names
  
  # Set dimnames on transition counts
  dimnames(trans_counts) <- list(
    state_names,
    state_names,
    NULL
  )
  
  structure(
    counts_df,
    class = c("cycle_counts", class(counts_df)),
    transitions = trans_counts[ , , -1, drop = F]
  )
}

#' Compute State Values per Cycle
#' 
#' Given states and counts, computes the total state values 
#' per cycle.
#' 
#' @param states An object of class `eval_state_list`.
#' @param counts An object of class `cycle_counts`.
#'   
#' @return A data.frame of state values, one column per 
#'   state value and one row per cycle.
#'   
#' @keywords internal
## slightly harder to read than the original version, but much faster
## identical results to within a little bit of numerical noise
compute_values <- function(states, counts, init, inflow, starting) {
  states_names <- get_state_names(states)
  state_values_names <- get_state_value_names(states)
  
  n_states <- length(states_names)
  n_state_vals <- length(state_values_names)
  num_cycles <- nrow(counts)
  
  ## combine the list of states into a single large array
  dims_array_1 <- c(
    num_cycles,
    length(state_values_names),
    length(states_names))
  
  dims_array_2 <- dims_array_1 + c(0, 1, 0)
  
  state_val_array <- array(unlist(states), dim = dims_array_2)
  
  ## get rid of markov_cycle
  mc_col <- match("markov_cycle", names(states[[1]]))
  state_val_array <- state_val_array[, -mc_col, , drop = FALSE]
  
  ## put counts into a similar large array
  counts_mat <- array(unlist(counts[, states_names]),
                      dim = dims_array_1[c(1, 3, 2)])
  counts_mat <- aperm(counts_mat, c(1, 3, 2))
  
  # multiply, sum, and add markov_cycle back in
  vals_x_counts <- state_val_array * counts_mat
  wtd_sums <- rowSums(vals_x_counts, dims = 2) + starting * rowSums(inflow)
  wtd_sums[1, ] <- wtd_sums[1, ] + sum(init) * starting[1, ]
  
  # Handle transitional costs
  if(!is.null(attr(states, "transitions"))) {
    
    # Arrange trans counts into array to match state transitions
    st_count_mat <- array(
      rep(attr(counts, "transitions"), n_state_vals),
      dim = c(n_states, n_states, num_cycles, n_state_vals)
    )
    
    trans_values <- colSums(st_count_mat * attr(states, "transitions"), dim=2)
    
    wtd_sums <- wtd_sums + trans_values
    
  }
  
  res <- data.frame(markov_cycle = states[[1]]$markov_cycle, wtd_sums)
  names(res)[-1] <- state_values_names
  
  res
}