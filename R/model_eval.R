#' Evaluate Markov Model
#' 
#' Given an unevaluated Markov Model, an initial number of 
#' individual and a number of cycle to compute, returns the 
#' evaluated version of the objects and the count of 
#' individual per state per model cycle.
#' 
#' \code{init} need not be integer. E.g. specifying a vector
#' of type c(Q = 1, B = 0, C = 0, ...) returns the 
#' probabilities for an individual starting in state A to be
#' in each state, per cycle.
#' 
#' @param model An \code{uneval_model} object.
#' @param parameters Optional. An object generated by 
#'   \code{\link{define_parameters}}.
#' @param cycles positive integer. Number of Markov Cycles 
#'   to compute.
#' @param init numeric vector, same length as number of 
#'   model states. Number of individuals in each model state
#'   at the beginning.
#' @param method Counting method.
#'   
#' @return An \code{eval_model} object (actually a list of 
#'   evaluated parameters, matrix, states and cycles 
#'   counts).
#' 
#' @example inst/examples/example_eval_model.R
#' 
eval_model <- function(model, parameters, cycles, 
                       init, method) {
  
  stopifnot(
    cycles > 0,
    length(cycles) == 1,
    all(init >= 0)
  )
  
  parameters <- eval_parameters(parameters,
                                cycles = cycles)
  transition_matrix <- eval_matrix(get_matrix(model),
                                   parameters)
  states <- eval_state_list(get_states(model), parameters)
  
  count_table <- compute_counts(
    transition_matrix = transition_matrix,
    init = init,
    method = method
  )
  
  values <- compute_values(states, count_table)
  
  structure(
    list(
      parameters = parameters,
      transition_matrix = transition_matrix,
      states = states,
      counts = count_table,
      values = values
    ),
    class = c("eval_model"),
    init = init,
    cycles = cycles)
}

get_counts <- function(x){
  UseMethod("get_counts")
}

get_counts.eval_model <- function(x){
  x$counts
}

#' Compute Count of Individual in Each State per Cycle
#' 
#' Given an initial number of individual and an evaluated 
#' transition matrix, returns the number of individual per 
#' state per cycle.
#' 
#' Use the \code{method} argument to specify if transitions
#' are supposed to happen at the beginning or the end of
#' each cycle. Alternatively linear interpolation between 
#' cycles can be performed.
#' 
#' @param transition_matrix An \code{eval_matrix} object.
#' @param init numeric vector, same length as number of 
#'   model states. Number of individuals in each model state
#'   at the beginning.
#' @param method Counting method.
#'   
#' @return A \code{cycle_counts} object.
#' 
compute_counts <- function(
  transition_matrix, init,
  method
) {
  
  if (! length(init) == get_matrix_order(transition_matrix)) {
    stop(sprintf(
      "Length of 'init' vector (%i) differs from the number of states (%i).",
      length(init),
      get_matrix_order(transition_matrix)
    ))
  }
  
  list_counts <- Reduce(
    "%*%",
    transition_matrix,
    init,
    accumulate = TRUE
  )
  
  res <- dplyr::as.tbl(
    as.data.frame(
      matrix(
        unlist(list_counts),
        byrow = TRUE,
        ncol = get_matrix_order(transition_matrix)
      )
    )
  )
  
  colnames(res) <- get_state_names(transition_matrix)
  
  n0 <- res[- nrow(res), ]
  n1 <- res[-1, ]
  
  switch(
    method,
    "beginning" = {
      out <- n1
    },
    "end" = {
      out <- n0
    },
    "half-cycle" = {
      out <- n1
      out[1, ] <- out[1, ] + init / 2
      out[nrow(out), ] <- out[nrow(out), ] + out[nrow(out), ] / 2
    },
    "life-table" = {
      out <- (n0 + n1) / 2
    },
    {
      stop(sprintf("Unknown counting method, '%s'.", method))
    }
  )
  
  structure(out, class = c("cycle_counts", class(out)))
  
}


#' Compute State Values per Cycle
#' 
#' Given states and counts, computes the total state values
#' per cycle.
#' 
#' @param states An object of class \code{eval_state_list}.
#' @param counts An object of class \code{cycle_counts}.
#'   
#' @return A data.frame of state values, one column per
#'   state value and one row per cycle.
#'   
compute_values <- function(states, counts) {
  
  states_names <- get_state_names(states)
  state_values_names <- get_state_value_names(states)
  
  res <- data.frame(
    markov_cycle = states[[1]]$markov_cycle
  )
  # bottleneck!
  for (state_value in state_values_names) {
    res[state_value] <- 0
    
    for (state in states_names) {
      res[state_value] <-
        res[state_value] +
        counts[, state] * 
        states[[state]][, state_value]
    }
  }
  res
}
