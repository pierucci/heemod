% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration.R
\name{calibrate_model}
\alias{calibrate_model}
\alias{calibrate_model_from_tabular}
\title{Calibrate model parameters to match desired output}
\usage{
calibrate_model(run_model, param_names, matching_df, target_values,
  method = "Nelder-Mead", initial_values = NULL, demographics = NULL, ...)

calibrate_model_from_tabular(base_dir, ref_file, param_names, matching_df,
  target_values, method, run_demo, ...)
}
\arguments{
\item{run_model}{a run_model object}

\item{param_names}{names of the parameters to calibrate}

\item{matching_df}{List where each element specifies the function that
will be used to calculate a value that is matched with the respective value
in \code{matching.values}. See details.}

\item{target_values}{values we want the matching functions to match}

\item{method}{The optimization method from package \code{optimx} to use for the
calibration; defaults to "Nelder-Mead".}

\item{initial_values}{an optional matrix with each row providing a starting
point for the optimization.  (If a data frame is passed in, it will be
converted.) If not provided, the starting values from \code{run_model} will
be used.}

\item{demographics}{As for \code{run_model_tabular}.}

\item{...}{optional arguments to be passed to optimx; when running
\code{calibrate_model_from_tabular}, will also include all arguments to
\code{calibrate_model} other than run_model.}

\item{base_dir}{Directory where the files are located.}

\item{ref_file}{Name of the reference file.}

\item{run_demo}{When running from a tabular model, should the model be run
across demographic groups?}
}
\value{
A data frame in which each row has the calibrated values of
parameters in \code{param_names} for the corresponding row of
\code{initial_values}, along with the convergence code for each run.
}
\description{
Calibrate model parameters to match desired output
}
\details{
\code{matching_df} is a data.frame with four columns:  group,
strategy_name, states_to_sum, and cycles_to_sum.  Each value of group defines
a set of counts that will be added together and compared to the corresponding
element of \code{target_values}.  (Target values must be given in the order
of sorted group values.)   For each value of group, strategy_name can have
only one value; having more than one will cause an error. For each value of
group, \code{cycles_to_sum} and \code{states_to_sum} will be used to index
the counts from the corresponding strategy, and the sum of those counts will
be returned as the value to match.  The calibration minimizes the sum of
squared differences between the calculated values and the target values.

Parameters not being optimized are unchanged from the values in the model run
passed to \code{calibrate_model}.  If \code{initial_values} is \code{NULL},
initial values of the parameters being calibrated will also be taken from the
model run passed to \code{calibrate_model}.  Passing in initial values
allows (among other things) the user to check whether the calibration gets
the same results from different starting points.

Running calibrate_model does not change the model parameters - the user
must create a new model and run it if desired.

See also the vignette \code{k-calibration}.
}
\examples{

param <- define_parameters(p = 0.8)

mat <- define_transition(
  p, C,
  0, 1
)
mod <- define_strategy(
  transition = mat,
  A = define_state(cost=10, effect = 0.5), 
  B= define_state(cost = 5, effect = 0.8)
)

res_mod <- run_model(
  mod = mod,
  parameters = param,
  init = c(1000L, 0L),
  cycles = 10,
  cost = cost,
  effect = effect,
  method = "end"
)

target.final.count <- get_counts(res_mod, "A")$count[10]   #134.2177

simple_matching_df <- 
  data.frame(group = 1, strategy_name = "mod", cycles_to_sum = 10, states_to_sum = "A")
calibrate_model(res_mod,
                param_names = c("p"),
                matching_df = simple_matching_df,
                target_values = c(134.2177),
                method = c("L-BFGS-B"),
                initial_values = matrix(c(0.1, 0.5, 0.9), 
                                        dimnames = list(NULL, "p")), 
                lower = 0, upper = 1
)

}
